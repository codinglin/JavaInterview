## Redis 怎么保证缓存一致性？

当需要更新数据时，无论是先写到Redis里再写到MySQL，还是先写MySQL再写Redis，这两步写操作不能保证原子性，所以会出现Redis和MySQL里的数据不一致。因为写和读是并发的，没法保证顺序，如果对Redis里的数据**设置过期时间**就能够保证最终一致性，对架构做的优化只能降低不一致性发生的概率，不能从根本上避免不一致性。

● 先更新数据库，再更新缓存（×）：假设有线程A先更新数据库，线程B后更新缓存，然后由于网络原因，线程B先更新了缓存，最后线程A再更新缓存，这时候会出现数据库和缓存不一致的情况。

● 先更新缓存，在更新数据库（×）：因为以数据库的数据为准，所以先更新数据库。

● 先删除缓存，再更新数据库：如果删除了缓存Redis，还没有来得及写进MySQL数据库，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。怎么保证缓存一致性？

**解决办法**

* **延迟双删**

1）先删除缓存 2）再写数据库3）休眠500毫秒4）再次删除缓存。**那么，这个500毫秒怎么确定的，具体该休眠多久呢？**需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。

2）**设置缓存过期时间：**从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。

**该方案的弊端：**结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。

上面的方法在高并发情况下，休眠500毫秒太多了，并且吞吐量降低了，所以可以采取异步删除的策略，另起一个线程。**如果第二次删除缓存失败怎么办？**会再次出现缓存和数据库不一致的问题。

**延迟双删中的删为什么不是更新缓存，而是删除缓存？**

举个栗子：一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。

实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。

* ##### 异步更新缓存（基于订阅binlog的同步机制，分为7个步骤）

1.**读Redis**：热数据基本都在Redis

2.**写MySQL**: 增删改都是操作MySQL

3.**更新Redis数据**：一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

该方法主要强调的是读和写分开，读就redis专业读，写就mysql写然后同步，又读又写很容易有数据不一致。注意：除了binlog，常用的队列还可以使用**Redis**，Kafka，AMQ，RMQ，阿里的canal**。

● 先更新数据库，再删除缓存：如果这时候（1）缓存刚好失效，（2）线程A进行查询得到旧值，（3）线程B更新数据库，（4）删除缓存，（5）线程A写入缓存，则也会出现数据不一致情况。

然而，发生这种情况的概率又有多少呢？
 发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。

如果有人抬杠，一定要解决怎么办？

可以采用前面提到的延迟双删策略。

还有其他造成不一致的原因么？
 有的，这也是缓存更新策略（先删除缓存，再更新数据库）和缓存更新策略（先更新数据库，再删除缓存）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（先删除缓存，再更新数据库）里留下的最后一个疑问。如何解决？
提供一个保障的**重试机制**即可，这里给出两套方案，在这里只说明其中最好的一套，另一套会对业务代码造成大量的侵入，如下：

<img src="Redis问题整理.assets/image-20230306160134208.png" alt="image-20230306160134208" style="zoom:67%;" />

流程如下图所示：
 （1）更新数据库数据
 （2）数据库会将操作信息写入binlog日志当中
 （3）订阅binlog的程序提取出所需要的数据以及key
 （4）另起一段非业务代码，获得该信息
 （5）尝试更新、删除缓存操作，发现操作失败
 （6）将这些信息发送至消息队列
 （7）重新从消息队列中获得该数据，重试操作。

**备注说明**：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制，采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。